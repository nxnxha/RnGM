# miri_rencontre.py ‚Äî Miri Rencontre (full, interactions d√©f√©r√©es)
# ‚úî Bouton accueil ‚Üí DM modal + photo (upload ou URL) ‚Üí publication
# ‚úî Profils publics avec miniature √† gauche (thumbnail)
# ‚úî Boutons: ‚ù§Ô∏è Like | ‚ùå Pass | üì© Contacter | ‚úèÔ∏è Modifier | üóëÔ∏è Supprimer
# ‚úî Like/Pass fa√ßon Tinder + d√©tection de match (DM aux deux)
# ‚úî Logs d√©taill√©s [JJ/MM/AAAA HH:MM] pour TOUT (cr√©ation, √©dition, suppression, like, pass, match, contact)
# ‚úî Aucune commande slash‚Ä¶ sauf /speeddating (staff)
# ‚úî DEFER sur interactions pour √©viter ‚ÄúCette interaction a √©chou√©‚Äù

import os
import re
import json
import asyncio
from datetime import datetime, timedelta, timezone
from typing import Dict, Any, Optional, List, Tuple
from zoneinfo import ZoneInfo  # Python 3.9+

import discord
from discord import app_commands
from discord.ext import commands

# -------------------- CONFIG (IDs par d√©faut, override via env) --------------------
def env_int(name: str, default: int) -> int:
    try:
        return int(os.getenv(name, str(default)))
    except Exception:
        return default

DISCORD_TOKEN = os.getenv("DISCORD_TOKEN")                               # Railway ‚Üí Variables
GUILD_ID      = env_int("GUILD_ID",      1382730341944397967)
ROLE_ACCESS   = env_int("ROLE_ACCESS",   1401403405729267762)
CH_GIRLS      = env_int("CH_GIRLS",      1400520391793053841)
CH_BOYS       = env_int("CH_BOYS",       1400520396557521058)
CH_SPEED      = env_int("CH_SPEED",      1402665906546413679)
CH_LOGS       = env_int("CH_LOGS",       1403154919913033728)
CH_WELCOME    = env_int("CH_WELCOME",    1400808431941849178)   # met un ID si tu veux l‚Äôembed d‚Äôaccueil auto
FIRST_MSG_LIMIT = env_int("FIRST_MSG_LIMIT", 1)
DATA_FILE     = os.getenv("DATA_FILE", "rencontre_data.json")

TZ = ZoneInfo("Europe/Paris")

# -------------------- Intents --------------------
intents = discord.Intents.default()
intents.message_content = True
intents.members = True
intents.guilds = True

# -------------------- Storage JSON --------------------
class Storage:
    def __init__(self, path: str):
        self.path = path
        self.data: Dict[str, Any] = {
            "profiles": {},           # user_id -> profile dict
            "profile_msgs": {},       # user_id -> {channel_id, message_id}
            "first_msg_counts": {},   # "author:target" -> int
            "likes": {},              # user_id -> list of liked user_ids
            "passes": {},             # user_id -> list of passed user_ids
            "matches": []             # list of [uid1, uid2] sorted
        }
        self.load()

    def load(self):
        if os.path.exists(self.path):
            try:
                with open(self.path, "r", encoding="utf-8") as f:
                    self.data.update(json.load(f))
            except Exception:
                pass

    def save(self):
        try:
            with open(self.path, "w", encoding="utf-8") as f:
                json.dump(self.data, f, ensure_ascii=False, indent=2)
        except Exception:
            pass

    # ---- profiles ----
    def get_profile(self, uid: int) -> Optional[Dict[str, Any]]:
        return self.data["profiles"].get(str(uid))

    def set_profile(self, uid: int, prof: Dict[str, Any]):
        self.data["profiles"][str(uid)] = prof
        self.save()

    def delete_profile(self, uid: int):
        self.data["profiles"].pop(str(uid), None)
        self.data["profile_msgs"].pop(str(uid), None)
        # clean likes/passes/matches
        self.data["likes"].pop(str(uid), None)
        self.data["passes"].pop(str(uid), None)
        # remove matches containing uid
        new_matches = []
        for a, b in self.data["matches"]:
            if int(a) != uid and int(b) != uid:
                new_matches.append([a, b])
        self.data["matches"] = new_matches
        self.save()

    # ---- message refs ----
    def set_profile_msg(self, uid: int, channel_id: int, message_id: int):
        self.data["profile_msgs"][str(uid)] = {"channel_id": channel_id, "message_id": message_id}
        self.save()

    def get_profile_msg(self, uid: int) -> Optional[Dict[str, int]]:
        return self.data["profile_msgs"].get(str(uid))

    # ---- first message anti-spam ----
    def inc_first_msg(self, author_id: int, target_id: int) -> int:
        key = f"{author_id}:{target_id}"
        val = self.data["first_msg_counts"].get(key, 0) + 1
        self.data["first_msg_counts"][key] = val
        self.save()
        return val

    # ---- like/pass/match ----
    def like(self, user_id: int, target_id: int) -> bool:
        """Return True si ce like cr√©e un NOUVEAU match."""
        if str(user_id) == str(target_id):
            return False
        likes = self.data["likes"].setdefault(str(user_id), [])
        if target_id not in likes:
            likes.append(target_id)
            self.save()

        other_likes = set(self.data["likes"].get(str(target_id), []))
        if user_id in other_likes:
            pair = sorted([user_id, target_id])
            if pair not in [[int(a), int(b)] for a, b in self.data["matches"]]:
                self.data["matches"].append([str(pair[0]), str(pair[1])])
                self.save()
                return True
        return False

    def pass_(self, user_id: int, target_id: int):
        passes = self.data["passes"].setdefault(str(user_id), [])
        if target_id not in passes:
            passes.append(target_id)
            self.save()

storage = Storage(DATA_FILE)

# -------------------- Helpers --------------------
def now_ts() -> str:
    return datetime.now(TZ).strftime("[%d/%m/%Y %H:%M]")

def log_line(guild: discord.Guild, text: str):
    if not CH_LOGS:
        return
    ch = guild.get_channel(CH_LOGS)
    if isinstance(ch, discord.TextChannel):
        asyncio.create_task(ch.send(f"{now_ts()} {text}"))

def allowed_to_manage(inter: discord.Interaction, owner_id: int) -> bool:
    if inter.user.id == owner_id:
        return True
    if isinstance(inter.user, discord.Member) and inter.user.guild_permissions.manage_guild:
        return True
    return False

# -------------------- √âtats temporaires (DM photo apr√®s modal) --------------------
awaiting_photo: Dict[int, Dict[str, Any]] = {}  # uid -> {"profile":..., "is_edit": bool}

# -------------------- Vues & Modals --------------------
class StartFormView(discord.ui.View):
    """Bouton sur l'embed d'accueil du serveur ‚Üí envoie un DM avec un bouton qui ouvre le modal."""
    def __init__(self):
        super().__init__(timeout=None)

    @discord.ui.button(label="Cr√©er mon profil", style=discord.ButtonStyle.success, custom_id="start_profile_btn")
    async def start_profile_btn(self, interaction: discord.Interaction, button: discord.ui.Button):
        await interaction.response.defer(ephemeral=True)  # DEFER pour √©viter timeout
        try:
            dm = await interaction.user.create_dm()
            await dm.send(
                embed=discord.Embed(
                    title="Cr√©ation de ton profil ‚Äî DM",
                    description=(
                        "On va remplir le formulaire en **priv√©**.\n\n"
                        "1) Clique sur **D√©marrer** pour ouvrir le formulaire (modal)\n"
                        "2) √Ä la fin, **envoie une photo** (image **upload√©e** ou **lien**) dans ce DM\n"
                        "3) Je publierai ton profil et je te donnerai le r√¥le **Acc√®s Rencontre** ‚úÖ"
                    ),
                    color=discord.Color.purple()
                ),
                view=OpenModalView(is_edit=False)
            )
            await interaction.followup.send("üì© Je t'ai envoy√© un DM pour cr√©er ton profil.", ephemeral=True)
        except Exception:
            await interaction.followup.send("‚ö†Ô∏è Je ne peux pas t'√©crire en DM (DM ferm√©s ?).", ephemeral=True)

class OpenModalView(discord.ui.View):
    """Bouton dans le DM pour ouvrir la Modal (cr√©ation ou √©dition)."""
    def __init__(self, is_edit: bool):
        super().__init__(timeout=None)
        self.is_edit = is_edit

    @discord.ui.button(label="D√©marrer", style=discord.ButtonStyle.primary, custom_id="open_modal_btn")
    async def open_modal_btn(self, interaction: discord.Interaction, button: discord.ui.Button):
        # Ouvrir une modal EST une r√©ponse, pas besoin de defer
        await interaction.response.send_modal(ProfilModal(is_edit=self.is_edit))

class ProfilModal(discord.ui.Modal, title="Profil ‚Äî Formulaire"):
    def __init__(self, is_edit: bool):
        super().__init__(timeout=300)
        self.is_edit = is_edit
        self.age = discord.ui.TextInput(label="√Çge (>=18)", min_length=1, max_length=3, placeholder="18")
        self.genre = discord.ui.TextInput(label="Genre (Fille/Homme)", min_length=1, max_length=10, placeholder="Fille")
        self.orientation = discord.ui.TextInput(label="Attirance", required=False, max_length=50, placeholder="H√©t√©ro, Bi, etc.")
        self.passions = discord.ui.TextInput(label="Passions", required=False, style=discord.TextStyle.paragraph, max_length=300)
        self.activite = discord.ui.TextInput(label="Activit√© (ce que tu fais)", required=False, max_length=100)

    async def on_submit(self, interaction: discord.Interaction):
        if not isinstance(interaction.channel, discord.DMChannel):
            await interaction.response.send_message("Ouvre d‚Äôabord le **DM** depuis le serveur (bouton *Cr√©er mon profil*).", ephemeral=True)
            return
        try:
            age_val = int(str(self.age.value).strip())
        except Exception:
            await interaction.response.send_message("√Çge invalide.", ephemeral=True)
            return
        if age_val < 18:
            await interaction.response.send_message("‚ùå R√©serv√© aux 18 ans et plus.", ephemeral=True)
            return

        old = storage.get_profile(interaction.user.id) or {}
        photo_keep = old.get("photo_url", "")

        profile = {
            "age": age_val,
            "genre": str(self.genre.value).strip(),
            "orientation": str(self.orientation.value).strip(),
            "passions": str(self.passions.value).strip(),
            "activite": str(self.activite.value).strip(),
            "photo_url": photo_keep if self.is_edit else "",
            "updated_at": datetime.now(TZ).isoformat()
        }
        awaiting_photo[interaction.user.id] = {"profile": profile, "is_edit": self.is_edit}
        await interaction.response.send_message(
            ("‚úîÔ∏è Modif re√ßue ! " if self.is_edit else "‚úîÔ∏è Formulaire re√ßu ! ")
            + "Maintenant, **envoie une photo** dans ce DM (upload ou lien). "
              "√âcris `skip` pour ne pas changer/ajouter la photo.",
            ephemeral=True
        )

# ---------- Contact modal (pour tout le monde) ----------
class ContactModal(discord.ui.Modal, title="Premier message"):
    def __init__(self, target_id: int, logs_ch: Optional[discord.TextChannel]):
        super().__init__(timeout=300)
        self.target_id = target_id
        self.logs_ch = logs_ch
        self.msg = discord.ui.TextInput(
            label="Ton message (1er contact)",
            style=discord.TextStyle.paragraph,
            min_length=5,
            max_length=600,
            placeholder="Pr√©sente-toi vite fait et sois respectueux(se) üòâ"
        )
        self.add_item(self.msg)

    async def on_submit(self, interaction: discord.Interaction):
        author = interaction.user
        guild = discord.utils.get(interaction.client.guilds, id=GUILD_ID)
        target = guild.get_member(self.target_id) if guild else None
        if not target:
            await interaction.response.send_message("‚ùå Utilisateur introuvable.", ephemeral=True)
            return

        count = storage.inc_first_msg(author.id, target.id)
        if count > FIRST_MSG_LIMIT:
            await interaction.response.send_message(
                f"‚ùå Tu as d√©j√† envoy√© {FIRST_MSG_LIMIT} premier message √† cette personne. Attends une r√©ponse.",
                ephemeral=True
            )
            return

        txt = f"**{author.display_name}** souhaite te contacter :\n> {self.msg.value}\n\n(Tu peux r√©pondre directement √† ce message pour poursuivre.)"
        ok = True
        try:
            dm = await target.create_dm()
            await dm.send(txt)
        except Exception:
            ok = False

        if ok:
            await interaction.response.send_message("‚úÖ Message envoy√© en DM √† la personne.", ephemeral=True)
            log_line(guild, f"üì® Contact : {author} ({author.id}) ‚Üí {target} ({target.id})")
        else:
            await interaction.response.send_message("‚ö†Ô∏è Impossible d‚Äôenvoyer le DM (DM ferm√©s ?).", ephemeral=True)
            log_line(guild, f"‚ö†Ô∏è Contact rat√© (DM ferm√©s) : {author} ({author.id}) ‚Üí {target} ({target.id})")

# ---------- Edit modal (owner-only, d√©clench√©e via bouton) ----------
class EditProfilModal(discord.ui.Modal, title="Modifier mon profil"):
    def __init__(self, owner_id: int, original: Dict[str, Any]):
        super().__init__(timeout=300)
        self.owner_id = owner_id
        self.original = original

        self.age = discord.ui.TextInput(label="√Çge (>=18)", default=str(original.get("age","")), max_length=3)
        self.genre = discord.ui.TextInput(label="Genre (Fille/Homme)", default=original.get("genre",""), max_length=10)
        self.orientation = discord.ui.TextInput(label="Attirance", default=original.get("orientation",""), required=False, max_length=50)
        self.passions = discord.ui.TextInput(label="Passions", default=original.get("passions",""), required=False, style=discord.TextStyle.paragraph, max_length=300)
        self.activite = discord.ui.TextInput(label="Activit√©", default=original.get("activite",""), required=False, max_length=100)

    async def on_submit(self, interaction: discord.Interaction):
        if interaction.user.id != self.owner_id and not interaction.user.guild_permissions.manage_guild:
            await interaction.response.send_message("‚ùå Tu n‚Äôas pas l‚Äôautorisation.", ephemeral=True)
            return

        try:
            age_val = int(str(self.age.value).strip())
        except Exception:
            await interaction.response.send_message("√Çge invalide.", ephemeral=True)
            return
        if age_val < 18:
            await interaction.response.send_message("‚ùå R√©serv√© aux 18 ans et plus.", ephemeral=True)
            return

        prof = storage.get_profile(self.owner_id) or {}
        prof.update({
            "age": age_val,
            "genre": str(self.genre.value).strip(),
            "orientation": str(self.orientation.value).strip(),
            "passions": str(self.passions.value).strip(),
            "activite": str(self.activite.value).strip(),
            "updated_at": datetime.now(TZ).isoformat()
        })
        storage.set_profile(self.owner_id, prof)

        # Publier MAJ
        guild = interaction.guild
        member = guild.get_member(self.owner_id)
        view = ProfileView(owner_id=self.owner_id)
        embed = build_profile_embed(member, prof)
        ref = storage.get_profile_msg(self.owner_id)
        if ref:
            ch = guild.get_channel(ref["channel_id"])
            if isinstance(ch, discord.TextChannel):
                try:
                    msg = await ch.fetch_message(ref["message_id"])
                    await msg.edit(embed=embed, view=view, content=None)
                except Exception:
                    pass

        log_line(guild, f"‚úèÔ∏è √âdition : {member} ({member.id})")
        await interaction.response.send_message("‚úÖ Profil mis √† jour. (Pour changer la photo, DM une nouvelle image ou URL.)", ephemeral=True)

# -------------------- Vue principale sous chaque profil --------------------
class ProfileView(discord.ui.View):
    def __init__(self, owner_id: int):
        super().__init__(timeout=None)
        self.owner_id = owner_id

    # ‚ù§Ô∏è Like
    @discord.ui.button(emoji="‚ù§Ô∏è", label="Like", style=discord.ButtonStyle.success, custom_id="pf_like")
    async def like_btn(self, interaction: discord.Interaction, button: discord.ui.Button):
        await interaction.response.defer(ephemeral=True)  # DEFER
        author = interaction.user
        if author.id == self.owner_id:
            await interaction.followup.send("ü§® Tu ne peux pas te liker toi-m√™me.", ephemeral=True)
            return

        guild = interaction.guild
        is_match = storage.like(author.id, self.owner_id)
        log_line(guild, f"‚ù§Ô∏è Like : {author} ({author.id}) ‚Üí {self.owner_id}")
        await interaction.followup.send("‚ù§Ô∏è Not√© !", ephemeral=True)

        if is_match:
            a = guild.get_member(author.id)
            b = guild.get_member(self.owner_id)
            # DM aux deux
            for m1, m2 in [(a, b), (b, a)]:
                try:
                    dm = await m1.create_dm()
                    await dm.send(f"üî• **C‚Äôest un match !** Tu as lik√© **{m2.display_name}** et c‚Äôest r√©ciproque. √âcrivez-vous !")
                except Exception:
                    pass
            log_line(guild, f"üî• Match : {a} ({a.id}) ‚ù§Ô∏è {b} ({b.id})")

    # ‚ùå Pass
    @discord.ui.button(emoji="‚ùå", label="Pass", style=discord.ButtonStyle.secondary, custom_id="pf_pass")
    async def pass_btn(self, interaction: discord.Interaction, button: discord.ui.Button):
        await interaction.response.defer(ephemeral=True)  # DEFER
        author = interaction.user
        if author.id == self.owner_id:
            await interaction.followup.send("‚Ä¶ Pourquoi passer sur toi-m√™me ? üòÖ", ephemeral=True)
            return
        storage.pass_(author.id, self.owner_id)
        log_line(interaction.guild, f"‚ùå Pass : {author} ({author.id}) ‚Üí {self.owner_id}")
        await interaction.followup.send("üëå C‚Äôest not√©.", ephemeral=True)

    # üì© Contacter
    @discord.ui.button(emoji="üì©", label="Contacter", style=discord.ButtonStyle.primary, custom_id="pf_contact")
    async def contact_btn(self, interaction: discord.Interaction, button: discord.ui.Button):
        # Ouvrir une modal EST une r√©ponse; pas besoin de defer
        logs_ch = interaction.guild.get_channel(CH_LOGS) if CH_LOGS else None
        await interaction.response.send_modal(ContactModal(target_id=self.owner_id, logs_ch=logs_ch))

    # ‚úèÔ∏è Modifier (owner-only)
    @discord.ui.button(emoji="‚úèÔ∏è", label="Modifier", style=discord.ButtonStyle.secondary, custom_id="pf_edit")
    async def edit_btn(self, interaction: discord.Interaction, button: discord.ui.Button):
        await interaction.response.defer(ephemeral=True)  # DEFER
        if not allowed_to_manage(interaction, self.owner_id):
            await interaction.followup.send("‚ùå Tu ne peux pas modifier ce profil.", ephemeral=True)
            return
        prof = storage.get_profile(self.owner_id)
        if not prof:
            await interaction.followup.send("Profil introuvable.", ephemeral=True)
            return
        # On r√©pond par modal (√ßa remplace followup), donc pour √™tre safe : on envoie la modal AVANT un followup
        try:
            # On ne peut pas ouvrir une modal apr√®s un defer + followup. Ici on a juste defer (OK).
            await interaction.edit_original_response(content="")  # nettoie le pending (facultatif)
            await interaction.followup.send("‚úèÔ∏è Ouvre la fen√™tre d‚Äô√©dition‚Ä¶", ephemeral=True)
        except Exception:
            pass
        # Comme Discord n'autorise qu'une seule "r√©ponse", on utilise un petit trick:
        # relancer une interaction via un nouveau bouton serait overkill; ici on ouvre la modal directement:
        # (selon versions, ouvrir une modal apr√®s defer peut √©chouer; si c'est le cas, garder la modal c√¥t√© ContactModal/DM)
        try:
            await interaction.channel.send(
                f"{interaction.user.mention} ouvre la modification‚Ä¶ (si la modal ne s‚Äôouvre pas, utilise le DM)",
                delete_after=3
            )
        except Exception:
            pass
        # En pratique, pour full fiabilit√© des modals apr√®s defer, on peut basculer en DM:
        try:
            dm = await interaction.user.create_dm()
            await dm.send("‚úèÔ∏è Ouvre ce formulaire pour modifier ton profil :", delete_after=120)
            await dm.send(view=OpenModalView(is_edit=True))
        except Exception:
            pass

    # üóëÔ∏è Supprimer (owner-only)
    @discord.ui.button(emoji="üóëÔ∏è", label="Supprimer", style=discord.ButtonStyle.danger, custom_id="pf_delete")
    async def del_btn(self, interaction: discord.Interaction, button: discord.ui.Button):
        await interaction.response.defer(ephemeral=True)  # DEFER
        if not allowed_to_manage(interaction, self.owner_id):
            await interaction.followup.send("‚ùå Tu ne peux pas supprimer ce profil.", ephemeral=True)
            return

        ref = storage.get_profile_msg(self.owner_id)
        storage.delete_profile(self.owner_id)

        # Supprimer le message si possible
        if ref:
            ch = interaction.guild.get_channel(ref["channel_id"])
            if isinstance(ch, discord.TextChannel):
                try:
                    msg = await ch.fetch_message(ref["message_id"])
                    await msg.delete()
                except Exception:
                    pass

        member = interaction.guild.get_member(self.owner_id)
        log_line(interaction.guild, f"üóëÔ∏è Suppression : {member} ({member.id})")
        await interaction.followup.send("‚úÖ Profil supprim√©.", ephemeral=True)

# -------------------- Fonctions profil --------------------
def build_profile_embed(member: discord.Member, prof: Dict[str, Any]) -> discord.Embed:
    e = discord.Embed(
        title=f"Profil de {member.display_name}",
        description="Espace Rencontre ‚Äî Miri",
        color=discord.Color.purple()
    )
    e.set_author(name=str(member), icon_url=member.display_avatar.url if member.display_avatar else None)
    # miniature (gauche)
    if prof.get("photo_url"):
        e.set_thumbnail(url=prof["photo_url"])

    fields = [
        ("√Çge", f"{prof.get('age', '‚Äî')}", True),
        ("Genre", prof.get('genre', '‚Äî') or "‚Äî", True),
        ("Attirance", prof.get('orientation', '‚Äî') or "‚Äî", True),
        ("Passions", prof.get('passions', '‚Äî') or "‚Äî", False),
        ("Activit√©", prof.get('activite', '‚Äî') or "‚Äî", False),
    ]
    for n, v, inline in fields:
        e.add_field(name=n, value=v, inline=inline)

    e.set_footer(text="‚ù§Ô∏è Like  ‚Ä¢  ‚ùå Pass  ‚Ä¢  üì© Contacter  ‚Ä¢  ‚úèÔ∏è Modifier  ‚Ä¢  üóëÔ∏è Supprimer")
    return e

def target_channel_for(guild: discord.Guild, prof: Dict[str, Any]) -> Optional[discord.TextChannel]:
    gender = (prof.get("genre") or "").strip().lower()
    if gender.startswith("f"):
        return guild.get_channel(CH_GIRLS)
    return guild.get_channel(CH_BOYS)

async def publish_or_update_profile(guild: discord.Guild, member: discord.Member, prof: Dict[str, Any]):
    view = ProfileView(owner_id=member.id)
    embed = build_profile_embed(member, prof)
    ref = storage.get_profile_msg(member.id)
    if ref:
        ch = guild.get_channel(ref["channel_id"])
        if isinstance(ch, discord.TextChannel):
            try:
                msg = await ch.fetch_message(ref["message_id"])
                await msg.edit(embed=embed, view=view, content=None)
                return
            except Exception:
                pass
    # New publish
    ch = target_channel_for(guild, prof)
    if not isinstance(ch, discord.TextChannel):
        return
    msg = await ch.send(embed=embed, view=view)
    storage.set_profile_msg(member.id, ch.id, msg.id)

# -------------------- Bot / Events --------------------
class RencontreBot(commands.Bot):
    def __init__(self):
        super().__init__(command_prefix="!", intents=intents)
        self.synced = False

    async def setup_hook(self):
        # Vues persistantes (accueil / DM start)
        self.add_view(StartFormView())
        self.add_view(OpenModalView(is_edit=False))
        self.add_view(OpenModalView(is_edit=True))
        # ProfileView: recr√©√©e √† chaque message

    async def on_ready(self):
        try:
            if not self.synced:
                self.synced = True  # pas de sync slash ici (on ajoute /speeddating plus bas)
        except Exception as e:
            print("[Sync error]", e)

        print(f"‚úÖ Connect√© en tant que {self.user} ({self.user.id})")

        # Embed d‚Äôaccueil avec bouton (si CH_WELCOME d√©fini)
        if CH_WELCOME:
            ch = self.get_channel(CH_WELCOME)
            if isinstance(ch, discord.TextChannel):
                try:
                    await ch.send(
                        embed=discord.Embed(
                            title="**Bienvenue dans l‚ÄôEspace Rencontre de Miri !**",
                            description=(
                                "Ici, tu peux cr√©er ton profil et d√©couvrir ceux des autres membres.\n"
                                "Likes, matchs, MP priv√©s, des soir√©es speed dating‚Ä¶ tout est fait pour favoriser de vraies connexions.\n\n"
                                "‚ö†Ô∏è Syst√®me r√©serv√© aux **18 ans et plus**.\n\n"
                                "Clique ci-dessous pour commencer :"
                            ),
                            color=discord.Color.purple()
                        ),
                        view=StartFormView()
                    )
                except Exception:
                    pass

    async def on_message(self, message: discord.Message):
        # Capture de la photo en DM apr√®s (cr√©ation/√©dition)
        if message.author.bot:
            return
        if isinstance(message.channel, discord.DMChannel):
            uid = message.author.id
            if uid in awaiting_photo:
                photo_url = None
                # Pi√®ce jointe image
                if message.attachments:
                    att = message.attachments[0]
                    if (att.content_type and att.content_type.startswith("image")) or att.filename.lower().endswith((".png",".jpg",".jpeg",".webp",".gif")):
                        photo_url = att.url
                # URL dans le texte
                if not photo_url:
                    m = re.search(r'https?://\S+', message.content)
                    if m:
                        photo_url = m.group(0)
                # Skip
                if message.content.strip().lower() in {"skip", "aucune", "non", "ignore"}:
                    photo_url = ""  # autorise vide

                payload = awaiting_photo.pop(uid)
                prof = payload["profile"]
                is_edit = payload.get("is_edit", False)
                if photo_url is not None:
                    prof["photo_url"] = photo_url

                guild = discord.utils.get(self.guilds, id=GUILD_ID)
                if not guild:
                    await message.channel.send("‚ö†Ô∏è Je ne trouve pas le serveur. R√©essaie plus tard.")
                    return
                member = guild.get_member(uid)
                if not member:
                    await message.channel.send("‚ö†Ô∏è Je ne te trouve pas sur le serveur.")
                    return

                storage.set_profile(uid, prof)
                await publish_or_update_profile(guild, member, prof)

                # donner le r√¥le acc√®s si cr√©ation
                if not is_edit and ROLE_ACCESS:
                    role = guild.get_role(ROLE_ACCESS)
                    if role:
                        try:
                            await member.add_roles(role, reason="Cr√©ation du profil Rencontre")
                        except Exception:
                            pass

                if is_edit:
                    log_line(guild, f"‚úèÔ∏è √âdition (photo {'chang√©e' if photo_url else 'inchang√©e'}) : {member} ({member.id})")
                    await message.channel.send("‚úÖ Profil mis √† jour.")
                else:
                    log_line(guild, f"‚úÖ Cr√©ation profil : {member} ({member.id}) + r√¥le Acc√®s Rencontre")
                    await message.channel.send("‚úÖ Profil cr√©√©. Bienvenue dans l‚ÄôEspace Rencontre !")

# -------------------- /speeddating (seule commande slash) --------------------
class SpeedCog(commands.Cog):
    def __init__(self, bot: commands.Bot):
        self.bot = bot

    @app_commands.command(name="speeddating", description="Cr√©e des threads priv√©s √©ph√©m√®res pour les actifs de la derni√®re heure (staff).")
    @app_commands.checks.has_permissions(manage_channels=True)
    async def speeddating(self, interaction: discord.Interaction, couples: int = 5):
        if not CH_SPEED:
            await interaction.response.send_message("‚ùå CH_SPEED non d√©fini.", ephemeral=True)
            return
        speed_ch = interaction.guild.get_channel(CH_SPEED)
        if not isinstance(speed_ch, discord.TextChannel):
            await interaction.response.send_message("‚ùå Salon speed introuvable.", ephemeral=True)
            return

        cutoff = datetime.now(timezone.utc) - timedelta(hours=1)
        authors: List[int] = []
        try:
            async for m in speed_ch.history(limit=500, oldest_first=False, after=cutoff):
                if m.author.bot:
                    continue
                if m.author.id not in authors:
                    authors.append(m.author.id)
        except Exception:
            pass

        if len(authors) < 2:
            await interaction.response.send_message("Pas assez de personnes actives dans l‚Äôheure.", ephemeral=True)
            return

        import random
        random.shuffle(authors)
        pairs: List[Tuple[int,int]] = []
        while len(authors) >= 2 and len(pairs) < couples:
            a = authors.pop()
            b = authors.pop()
            if a == b:
                continue
            pairs.append((a, b))

        created_threads = []
        for a, b in pairs:
            ma = interaction.guild.get_member(a)
            mb = interaction.guild.get_member(b)
            if not ma or not mb:
                continue
            name = f"Speed ‚è≥ {ma.display_name} √ó {mb.display_name}"
            try:
                thread = await speed_ch.create_thread(
                    name=name,
                    type=discord.ChannelType.private_thread,
                    invitable=False
                )
                await thread.add_user(ma)
                await thread.add_user(mb)
                await thread.send(f"Bienvenue {ma.mention} et {mb.mention} ‚Äî vous avez **5 minutes** ‚è≥. Soyez respectueux/sses.")
                created_threads.append(thread)
            except Exception:
                continue

        await interaction.response.send_message(f"‚úÖ Cr√©√© {len(created_threads)} threads √©ph√©m√®res.", ephemeral=True)

        await asyncio.sleep(5 * 60)
        for t in created_threads:
            try:
                await t.edit(archived=True, locked=True)
            except Exception:
                pass

# -------------------- Entr√©e --------------------
bot = RencontreBot()
speed = SpeedCog(bot)
bot.tree.add_command(speed.speeddating, guild=discord.Object(id=GUILD_ID) if GUILD_ID else None)

if __name__ == "__main__":
    if not DISCORD_TOKEN:
        raise SystemExit("DISCORD_TOKEN est requis (mets-le en variable d‚Äôenvironnement).")
    bot.run(DISCORD_TOKEN)

